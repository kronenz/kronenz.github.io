---
layout: default
title: "1-4: `spec.md` 작성의 기술 - AI가 이해하는 명확한 명세서 작성법"
description: "에이전틱 SaaS 조직 가이드"
series: "series-1"
order: 6
---

# 1-4: `spec.md` 작성의 기술 - AI가 이해하는 명확한 명세서 작성법

## 📋 개요

AI가 완벽하게 이해하고 실행할 수 있는 명세서를 작성하는 것은 에이전틱 개발의 핵심입니다. 이 가이드에서는 AI 친화적 명세서 작성 원칙과 구체적인 기법을 학습합니다.

## 🎯 학습 목표

이 가이드를 완료하면 다음을 달성할 수 있습니다:

1. **AI 친화적 명세서 작성 원칙 이해**
2. **명확하고 모호함 없는 명세서 작성 능력**
3. **구조화된 명세서 템플릿 활용**
4. **실제 프로젝트에 적용 가능한 명세서 작성**

## 🤖 AI가 이해하는 명세서의 특징

### AI 친화적 명세서의 핵심 원칙

#### 1. 명확성 (Clarity)
- **모호함 제거**: "좋은", "빠른", "사용자 친화적" 같은 주관적 표현 금지
- **구체적 수치**: 정확한 성능 지표와 제약 조건 명시
- **일관된 용어**: 동일한 개념에 대해 항상 같은 용어 사용

```markdown
# 나쁜 예: 모호한 명세
"사용자 인터페이스가 직관적이어야 함"
"빠른 응답 시간을 제공해야 함"
"안전한 데이터 처리가 필요함"

# 좋은 예: 명확한 명세
"사용자는 3번의 클릭 이내에 원하는 기능에 접근할 수 있어야 함"
"API 응답 시간은 95%의 요청에서 200ms 이내여야 함"
"모든 사용자 입력은 OWASP Top 10 기준에 따라 검증되어야 함"
```markdown

#### 2. 구조화 (Structure)
- **계층적 구성**: 명확한 섹션과 하위 섹션 구조
- **논리적 순서**: 의존성에 따른 논리적 배치
- **표준화된 형식**: 일관된 마크다운 형식 사용

```markdown
# 명세서 구조 템플릿
# 프로젝트명

## 📋 기본 정보
- 프로젝트명, 버전, 작성일, 작성자, 상태

## 🎯 프로젝트 개요
- 목적, 배경, 성공 기준

## 👥 이해관계자
- 주요 이해관계자, AI 에이전트 팀

## 📝 기능 요구사항
- 핵심 기능, 부가 기능

## 🔧 기술 요구사항
- 기술 스택, 성능 요구사항, 보안 요구사항

## 🎨 사용자 경험
- 사용자 시나리오, UI/UX 요구사항

## 📊 데이터 모델
- 주요 엔티티, API 설계

## 🧪 테스트 요구사항
- 테스트 유형, 테스트 시나리오

## 🚀 배포 요구사항
- 환경, 배포 전략

## 📅 일정 및 마일스톤
- 개발 일정, 마일스톤

## ⚠️ 위험 요소 및 대응 방안
- 기술적 위험, 비즈니스 위험

## 📚 참고 자료
- 관련 문서, 링크

## ✅ 승인
- 이해관계자 승인
```markdown

#### 3. 완전성 (Completeness)
- **모든 측면 커버**: 기능, 비기능, 기술, 비즈니스 요구사항
- **예외 상황 고려**: 에러 케이스와 예외 상황 명시
- **제약 조건 명시**: 기술적, 비즈니스적 제약 조건

#### 4. 검증 가능성 (Verifiability)
- **측정 가능한 기준**: 정량적 성과 지표
- **테스트 가능한 요구사항**: 자동화된 검증 가능
- **명확한 완료 기준**: 언제 완료되었는지 명확

## 📝 명세서 작성 단계별 가이드

### 1단계: 프로젝트 개요 정의

#### 목적과 배경 명확화
```markdown
## 🎯 프로젝트 개요

### 목적
온라인 쇼핑몰의 장바구니 기능을 구현하여 사용자가 상품을 선택하고 구매 전까지 임시 저장할 수 있는 기능을 제공합니다.

### 배경
현재 쇼핑몰에는 장바구니 기능이 없어 사용자가 여러 상품을 선택한 후 한 번에 구매하는 것이 불가능합니다. 이로 인해 사용자 경험이 저하되고 매출 손실이 발생하고 있습니다.

### 성공 기준
- [ ] 사용자가 상품을 장바구니에 추가할 수 있음
- [ ] 장바구니에 담긴 상품의 수량을 조절할 수 있음
- [ ] 장바구니 총 금액이 실시간으로 계산됨
- [ ] 장바구니 내용이 브라우저를 닫았다가 다시 열어도 유지됨
- [ ] 모바일과 데스크톱에서 모두 정상 작동함
- [ ] 페이지 로드 시간이 2초 이내임
```markdown

#### 성공 기준 작성 기법
```markdown
# 성공 기준 작성 템플릿

## 기능적 요구사항
- [ ] [주어]가 [동작]할 수 있음
- [ ] [조건]에서 [결과]가 발생함
- [ ] [입력]에 대해 [출력]을 제공함

## 비기능적 요구사항
- [ ] [지표]가 [값] 이상/이하여야 함
- [ ] [상황]에서 [성능]을 유지해야 함
- [ ] [제약조건]을 준수해야 함

## 사용자 경험 요구사항
- [ ] 사용자가 [행동]을 [횟수]번 이내에 완료할 수 있음
- [ ] [사용자 그룹]이 [목표]를 달성할 수 있음
- [ ] [상황]에서 [반응]을 제공함
```markdown

### 2단계: 기능 요구사항 상세화

#### 사용자 스토리 기반 요구사항
```markdown
## 📝 기능 요구사항

### 핵심 기능

#### 1. 상품 장바구니 추가
**사용자 스토리**: 상품 상세 페이지에서 "장바구니에 추가" 버튼을 클릭하여 상품을 장바구니에 추가할 수 있어야 합니다.

**기능 상세**:
- 상품 ID, 이름, 가격, 수량을 장바구니에 저장
- 이미 장바구니에 있는 상품인 경우 수량 증가
- 장바구니에 추가된 상품은 즉시 화면에 표시
- 추가 성공 시 사용자에게 피드백 제공

**입력**: 상품 ID, 수량 (기본값: 1)
**출력**: 장바구니 업데이트, 성공 메시지
**예외**: 상품이 존재하지 않는 경우, 재고가 부족한 경우

#### 2. 장바구니 상품 수량 조절
**사용자 스토리**: 장바구니 페이지에서 상품의 수량을 증가/감소시킬 수 있어야 합니다.

**기능 상세**:
- +/- 버튼으로 수량 조절
- 직접 수량 입력 가능
- 수량이 0이 되면 상품 자동 삭제
- 수량 변경 시 총 금액 자동 재계산

**입력**: 상품 ID, 새로운 수량
**출력**: 업데이트된 장바구니, 재계산된 총 금액
**제약**: 수량은 1-99 사이의 정수

#### 3. 장바구니 상품 삭제
**사용자 스토리**: 장바구니에서 불필요한 상품을 삭제할 수 있어야 합니다.

**기능 상세**:
- 개별 상품 삭제 버튼 제공
- 삭제 확인 다이얼로그 표시
- 삭제 후 장바구니 자동 업데이트
- 빈 장바구니 상태 처리

**입력**: 상품 ID
**출력**: 상품 제거, 장바구니 업데이트
**예외**: 존재하지 않는 상품 ID
```markdown

#### 기능 요구사항 작성 체크리스트
```markdown
# 기능 요구사항 작성 체크리스트

## 각 기능에 대해 다음이 명시되었는가?
- [ ] 사용자 스토리 또는 사용자 관점
- [ ] 구체적인 기능 설명
- [ ] 입력과 출력 명시
- [ ] 예외 상황 처리
- [ ] 제약 조건 명시
- [ ] 우선순위 설정
- [ ] 복잡도 평가
- [ ] 예상 소요 시간
```markdown

### 3단계: 기술 요구사항 정의

#### 기술 스택 명시
```markdown
## 🔧 기술 요구사항

### 기술 스택
- **프론트엔드**: React 18, TypeScript 4.9+, CSS Modules
- **상태 오케스트레이션**: Context API + useReducer
- **빌드 도구**: Vite 4.0+
- **패키지 오케스트레이션**: npm 8.0+
- **개발 도구**: ESLint, Prettier, Husky

### 성능 요구사항
- **초기 로딩 시간**: 2초 이내
- **상호작용 응답 시간**: 100ms 이내
- **메모리 사용량**: 50MB 이하
- **번들 크기**: 500KB 이하 (gzipped)

### 브라우저 호환성
- **Chrome**: 90+
- **Firefox**: 88+
- **Safari**: 14+
- **Edge**: 90+
- **모바일**: iOS 14+, Android 8+

### 접근성 요구사항
- **WCAG 2.1 AA 준수**
- **키보드 네비게이션 지원**
- **스크린 리더 호환**
- **색상 대비 4.5:1 이상**
```markdown

#### API 설계 명세
```markdown
### API 설계

#### 장바구니 API 엔드포인트
```typescript
// 장바구니 아이템 타입
interface CartItem {
  id: string;
  productId: string;
  name: string;
  price: number;
  quantity: number;
  imageUrl?: string;
}

// API 응답 타입
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

// API 엔드포인트
interface CartAPI {
  // 장바구니 아이템 추가
  addItem(item: Omit<CartItem, 'id'>): Promise<ApiResponse<CartItem[]>>;
  
  // 장바구니 아이템 수량 업데이트
  updateQuantity(productId: string, quantity: number): Promise<ApiResponse<CartItem[]>>;
  
  // 장바구니 아이템 삭제
  removeItem(productId: string): Promise<ApiResponse<CartItem[]>>;
  
  // 장바구니 전체 조회
  getItems(): Promise<ApiResponse<CartItem[]>>;
  
  // 장바구니 비우기
  clearCart(): Promise<ApiResponse<void>>;
}
```
```

### 4단계: 데이터 모델 정의

#### 엔티티 관계 설계
```markdown
## 📊 데이터 모델

### 주요 엔티티

#### CartItem (장바구니 아이템)
```typescript
interface CartItem {
  // 기본 식별자
  id: string;                    // 장바구니 아이템 고유 ID
  productId: string;            // 상품 ID (외부 참조)
  
  // 상품 정보 (스냅샷)
  name: string;                 // 상품명
  price: number;                // 단가 (추가 시점 기준)
  imageUrl?: string;            // 상품 이미지 URL
  
  // 수량 정보
  quantity: number;             // 수량 (1-99)
  
  // 메타데이터
  addedAt: Date;               // 장바구니 추가 시각
  updatedAt: Date;             // 마지막 수정 시각
}
```markdown

#### Cart (장바구니)
```typescript
interface Cart {
  id: string;                   // 장바구니 고유 ID
  userId?: string;              // 사용자 ID (로그인 시)
  sessionId: string;            // 세션 ID (비로그인 시)
  items: CartItem[];            // 장바구니 아이템 목록
  createdAt: Date;              // 장바구니 생성 시각
  updatedAt: Date;              // 마지막 업데이트 시각
}
```markdown

### 데이터 저장 전략
- **로컬 저장소**: localStorage 사용 (브라우저 재시작 시에도 유지)
- **세션 저장소**: sessionStorage 사용 (탭 종료 시 삭제)
- **서버 동기화**: 로그인 시 서버와 동기화 (선택사항)
```markdown

### 5단계: 사용자 경험 명세

#### 사용자 시나리오 정의
```markdown
## 🎨 사용자 경험

### 사용자 시나리오

#### 시나리오 1: 상품 장바구니 추가
1. **시작**: 사용자가 상품 상세 페이지에 있음
2. **행동**: "장바구니에 추가" 버튼 클릭
3. **결과**: 
   - 상품이 장바구니에 추가됨
   - 장바구니 아이콘에 수량 표시 업데이트
   - "추가되었습니다" 토스트 메시지 표시
   - 장바구니 미리보기 표시 (선택사항)

#### 시나리오 2: 장바구니 수량 조절
1. **시작**: 사용자가 장바구니 페이지에 있음
2. **행동**: 상품의 수량 +/- 버튼 클릭
3. **결과**:
   - 수량이 즉시 업데이트됨
   - 총 금액이 자동으로 재계산됨
   - 변경사항이 로컬 저장소에 저장됨

#### 시나리오 3: 장바구니 상품 삭제
1. **시작**: 사용자가 장바구니 페이지에 있음
2. **행동**: 상품 옆의 "삭제" 버튼 클릭
3. **결과**:
   - 삭제 확인 다이얼로그 표시
   - 확인 시 상품이 장바구니에서 제거됨
   - 총 금액이 자동으로 재계산됨
```markdown

#### UI/UX 요구사항
```markdown
### UI/UX 요구사항

#### 반응형 디자인
- **데스크톱**: 1200px 이상 - 3열 그리드 레이아웃
- **태블릿**: 768px-1199px - 2열 그리드 레이아웃
- **모바일**: 767px 이하 - 1열 스택 레이아웃

#### 인터랙션 디자인
- **호버 효과**: 버튼과 링크에 0.2초 트랜지션
- **로딩 상태**: 비동기 작업 시 스피너 표시
- **에러 상태**: 명확한 에러 메시지와 복구 방법 제시
- **성공 피드백**: 작업 완료 시 시각적 피드백 제공

#### 접근성 요구사항
- **키보드 네비게이션**: Tab 키로 모든 인터랙티브 요소 접근 가능
- **스크린 리더**: ARIA 라벨과 역할 속성 적절히 설정
- **색상 대비**: WCAG 2.1 AA 기준 (4.5:1) 준수
- **포커스 표시**: 명확한 포커스 인디케이터 제공
```markdown

### 6단계: 테스트 요구사항 정의

#### 테스트 전략
```markdown
## 🧪 테스트 요구사항

### 테스트 유형

#### 1. 단위 테스트 (Unit Tests)
- **대상**: 개별 함수와 컴포넌트
- **도구**: Jest + React Testing Library
- **커버리지**: 80% 이상
- **예시**:
  - 장바구니 총 금액 계산 함수
  - 상품 수량 유효성 검사 함수
  - 장바구니 아이템 추가/삭제 함수

#### 2. 통합 테스트 (Integration Tests)
- **대상**: 컴포넌트 간 상호작용
- **도구**: Jest + React Testing Library
- **예시**:
  - 장바구니 추가 → 목록 업데이트
  - 수량 변경 → 총 금액 재계산
  - 로컬 저장소 동기화

#### 3. E2E 테스트 (End-to-End Tests)
- **대상**: 전체 사용자 워크플로우
- **도구**: Playwright
- **예시**:
  - 상품 상세 → 장바구니 추가 → 장바구니 페이지 확인
  - 장바구니 수량 조절 → 총 금액 확인
  - 브라우저 재시작 → 장바구니 데이터 유지 확인

### 테스트 시나리오

#### 시나리오 1: 정상 플로우
1. 상품을 장바구니에 추가
2. 장바구니 페이지에서 수량 조절
3. 불필요한 상품 삭제
4. 총 금액 확인

#### 시나리오 2: 예외 상황
1. 재고 부족 상품 추가 시도
2. 잘못된 수량 입력
3. 네트워크 오류 상황
4. 브라우저 저장소 용량 초과

#### 시나리오 3: 성능 테스트
1. 대량 상품 추가 (100개 이상)
2. 빠른 연속 수량 변경
3. 메모리 사용량 모니터링
4. 렌더링 성능 측정
```markdown

## 🛠️ 명세서 작성 도구와 템플릿

### 명세서 템플릿

```markdown
# [프로젝트명] 명세서

## 📋 기본 정보
- **프로젝트명**: [프로젝트 이름]
- **버전**: 1.0.0
- **작성일**: [YYYY-MM-DD]
- **작성자**: [작성자명]
- **상태**: [Draft/Review/Approved]

## 🎯 프로젝트 개요
### 목적
[프로젝트의 목적과 비즈니스 가치를 명확히 기술]

### 배경
[프로젝트가 필요한 배경과 문제 상황 설명]

### 성공 기준
- [ ] [측정 가능한 성공 기준 1]
- [ ] [측정 가능한 성공 기준 2]
- [ ] [측정 가능한 성공 기준 3]

## 👥 이해관계자
### 주요 이해관계자
- **제품 소유자**: [이름, 연락처]
- **기술 리더**: [이름, 연락처]
- **최종 사용자**: [사용자 그룹 설명]

### AI 에이전트 팀
- **제품 전략가**: 요구사항 분석 및 명세 작성
- **개발자**: 코드 구현 및 테스트
- **QA 엔지니어**: 품질 보증 및 테스트
- **DevOps 엔지니어**: 배포 및 운영

## 📝 기능 요구사항
### 핵심 기능
1. **[기능 1]**
   - 설명: [기능에 대한 상세 설명]
   - 우선순위: [High/Medium/Low]
   - 복잡도: [Simple/Medium/Complex]
   - 예상 소요시간: [시간]

2. **[기능 2]**
   - 설명: [기능에 대한 상세 설명]
   - 우선순위: [High/Medium/Low]
   - 복잡도: [Simple/Medium/Complex]
   - 예상 소요시간: [시간]

### 부가 기능
1. **[기능 A]**
   - 설명: [기능에 대한 상세 설명]
   - 우선순위: [High/Medium/Low]

## 🔧 기술 요구사항
### 기술 스택
- **프론트엔드**: [기술 스택]
- **백엔드**: [기술 스택]
- **데이터베이스**: [데이터베이스]
- **인프라**: [클라우드/온프레미스]

### 성능 요구사항
- **응답 시간**: [초 이내]
- **동시 사용자**: [명]
- **가용성**: [%]
- **처리량**: [TPS/RPS]

### 보안 요구사항
- **인증**: [인증 방식]
- **인가**: [권한 오케스트레이션 방식]
- **데이터 보호**: [암호화 방식]
- **규정 준수**: [준수해야 할 규정]

## 🎨 사용자 경험
### 사용자 시나리오
1. **시나리오 1**: [사용자 행동 시나리오]
2. **시나리오 2**: [사용자 행동 시나리오]

### UI/UX 요구사항
- **디자인 시스템**: [사용할 디자인 시스템]
- **반응형**: [모바일/태블릿/데스크톱 지원]
- **접근성**: [접근성 요구사항]

## 📊 데이터 모델
### 주요 엔티티
1. **엔티티 1**
   - 속성: [속성 목록]
   - 관계: [다른 엔티티와의 관계]

2. **엔티티 2**
   - 속성: [속성 목록]
   - 관계: [다른 엔티티와의 관계]

### API 설계
- **엔드포인트 1**: [HTTP 메서드] [URL]
- **엔드포인트 2**: [HTTP 메서드] [URL]

## 🧪 테스트 요구사항
### 테스트 유형
- [ ] 단위 테스트
- [ ] 통합 테스트
- [ ] E2E 테스트
- [ ] 성능 테스트
- [ ] 보안 테스트

### 테스트 시나리오
1. **시나리오 1**: [테스트 케이스 설명]
2. **시나리오 2**: [테스트 케이스 설명]

## 🚀 배포 요구사항
### 환경
- **개발**: [개발 환경 설정]
- **스테이징**: [스테이징 환경 설정]
- **프로덕션**: [프로덕션 환경 설정]

### 배포 전략
- **배포 방식**: [Blue-Green/Canary/Rolling]
- **롤백 계획**: [롤백 시나리오]
- **모니터링**: [모니터링 도구 및 지표]

## 📅 일정 및 마일스톤
### 개발 일정
- **Phase 1**: [기간] - [주요 기능]
- **Phase 2**: [기간] - [주요 기능]
- **Phase 3**: [기간] - [주요 기능]

### 마일스톤
- [ ] [날짜] - [마일스톤 1]
- [ ] [날짜] - [마일스톤 2]
- [ ] [날짜] - [마일스톤 3]

## ⚠️ 위험 요소 및 대응 방안
### 기술적 위험
- **위험 1**: [위험 설명] → [대응 방안]
- **위험 2**: [위험 설명] → [대응 방안]

### 비즈니스 위험
- **위험 1**: [위험 설명] → [대응 방안]
- **위험 2**: [위험 설명] → [대응 방안]

## 📚 참고 자료
- [링크 1]: [설명]
- [링크 2]: [설명]
- [문서 1]: [설명]

## ✅ 승인
- **제품 소유자**: [이름] - [날짜]
- **기술 리더**: [이름] - [날짜]
- **AI 팀 리더**: [이름] - [날짜]

---

**이 명세서는 AI 에이전트 팀이 프로젝트를 성공적으로 완료하기 위한 가이드라인입니다.**
```markdown

### 명세서 검증 도구

```python
# 명세서 품질 검증 도구
class SpecValidator:
    def __init__(self):
        self.rules = [
            self.check_clarity,
            self.check_completeness,
            self.check_consistency,
            self.check_verifiability
        ]
    
    def validate(self, spec_content):
        results = []
        for rule in self.rules:
            result = rule(spec_content)
            results.append(result)
        
        return {
            "overall_score": sum(r["score"] for r in results) / len(results),
            "details": results,
            "recommendations": self.generate_recommendations(results)
        }
    
    def check_clarity(self, content):
        """명확성 검사"""
        issues = []
        
        # 모호한 표현 검사
        vague_terms = ["좋은", "빠른", "사용자 친화적", "적절한"]
        for term in vague_terms:
            if term in content:
                issues.append(f"모호한 표현 발견: '{term}'")
        
        # 구체적 수치 부족 검사
        if not self.has_quantitative_metrics(content):
            issues.append("정량적 지표가 부족합니다")
        
        return {
            "rule": "명확성",
            "score": max(0, 100 - len(issues) * 20),
            "issues": issues
        }
    
    def check_completeness(self, content):
        """완전성 검사"""
        required_sections = [
            "프로젝트 개요", "기능 요구사항", "기술 요구사항",
            "사용자 경험", "데이터 모델", "테스트 요구사항"
        ]
        
        missing_sections = []
        for section in required_sections:
            if section not in content:
                missing_sections.append(section)
        
        return {
            "rule": "완전성",
            "score": max(0, 100 - len(missing_sections) * 15),
            "issues": [f"누락된 섹션: {s}" for s in missing_sections]
        }
```

## 📊 명세서 품질 측정

### 품질 지표
- **명확성 점수**: 모호한 표현과 구체적 수치 비율
- **완전성 점수**: 필수 섹션 포함 여부
- **일관성 점수**: 용어 사용 일관성
- **검증 가능성**: 측정 가능한 기준 포함 여부

### 개선 지표
- **명세서 작성 시간**: 초기 작성부터 승인까지
- **수정 횟수**: 명세서 변경 횟수
- **이해도 점수**: 팀원들의 명세서 이해도
- **실행 정확도**: 명세 대비 실제 구현 일치도

## 🚀 다음 단계

이 가이드를 완료한 후에는 다음 단계로 진행하세요:

1. **[1-5: `/plan`과 `/tasks` 활용법](1-5-plan-tasks-utilization.md)**
2. **[1-6: 이중 LLM 인지 아키텍처 구축](1-6-dual-llm-architecture.md)**

## 📚 추가 리소스

- [명세서 작성 모범 사례](https://spec-best-practices.dev/)
- [AI 친화적 문서 작성 가이드](https://ai-documentation.dev/)
- [요구사항 분석 기법](https://requirements-analysis.dev/)

---

**"명확한 명세가 완벽한 구현의 시작"** - AI가 이해하는 명세서의 핵심
