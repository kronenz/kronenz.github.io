---
title: ìê°€ ì¹˜ìœ  í…ŒìŠ¤íŠ¸ì˜ êµ¬í˜„
date: 2025-09-18 20:04:21
updated: 2025-09-18 20:04:21
categories: ["AI ê°€ì´ë“œ"]
tags: ["AI", "ê°€ì´ë“œ", "ìë™í™”"]
permalink: /series-2/2-9-self-healing-tests/
excerpt: 
toc: True
mathjax: True
comments: True
series:
  id: series-2
  title: ì‹œë¦¬ì¦ˆ 2: ìë™í™”ëœ SaaS íŒ©í† ë¦¬ - ì¡°ë¦½ ë¼ì¸ êµ¬ì¶• ê°€ì´ë“œ
  position: 1
---
<h1 id="_1">ìê°€ ì¹˜ìœ  í…ŒìŠ¤íŠ¸ì˜ êµ¬í˜„</h1>
<h2 id="ui-qa">UI ë³€ê²½ì— ìë™ìœ¼ë¡œ ì ì‘í•˜ëŠ” íšŒë³µíƒ„ë ¥ì„± ìˆëŠ” QA ì‹œìŠ¤í…œ</h2>
<h2 id="_2">ğŸ“– ê°œìš”</h2>
<p>ì´ ê°€ì´ë“œëŠ” UI ë³€ê²½ì´ë‚˜ ìš”ì†Œ ì‹ë³„ì ë³€ê²½ì— ìë™ìœ¼ë¡œ ì ì‘í•˜ì—¬ í…ŒìŠ¤íŠ¸ê°€ ê³„ì† ì‘ë™í•˜ë„ë¡ í•˜ëŠ” ìê°€ ì¹˜ìœ  í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ëŠ” ë°©ë²•ì„ ë‹¤ë£¹ë‹ˆë‹¤. í…ŒìŠ¤íŠ¸ì˜ ì•ˆì •ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì„ í¬ê²Œ í–¥ìƒì‹œí‚µë‹ˆë‹¤.</p>
<h2 id="_3">ğŸ¯ í•™ìŠµ ëª©í‘œ</h2>
<p>ì´ ê°€ì´ë“œë¥¼ ì™„ë£Œí•˜ë©´ ë‹¤ìŒì„ ë‹¬ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:</p>
<ul>
<li>ìê°€ ì¹˜ìœ  í…ŒìŠ¤íŠ¸ ê°œë… ì´í•´ ë° ì„¤ê³„</li>
<li>ë™ì  ìš”ì†Œ ì„ íƒì ì‹œìŠ¤í…œ êµ¬í˜„</li>
<li>í…ŒìŠ¤íŠ¸ ì•ˆì •ì„± í–¥ìƒ ë©”ì»¤ë‹ˆì¦˜ êµ¬ì¶•</li>
<li>ì‹¤íŒ¨ ì‹œ ìë™ ìˆ˜ì • ì‹œìŠ¤í…œ ê°œë°œ</li>
<li>AI ê¸°ë°˜ ìš”ì†Œ ì‹ë³„ ë° ë§¤ì¹­ ì‹œìŠ¤í…œ êµ¬í˜„</li>
</ul>
<h2 id="_4">ğŸ“‹ ì‚¬ì „ ìš”êµ¬ì‚¬í•­</h2>
<ul>
<li>Selenium/Playwright ê¸°ë³¸ ì§€ì‹</li>
<li>Python ì¤‘ê¸‰ ìˆ˜ì¤€</li>
<li>ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë³¸ ê°œë…</li>
<li>ì›¹ ê°œë°œ ê¸°ë³¸ ì§€ì‹</li>
</ul>
<h2 id="_5">â±ï¸ ì˜ˆìƒ ì†Œìš” ì‹œê°„</h2>
<p><strong>4ì‹œê°„</strong> (ë‚œì´ë„: ê³ ê¸‰)</p>
<h2 id="_6">ğŸ”§ í•„ìš”í•œ ë„êµ¬</h2>
<ul>
<li>Python 3.8+</li>
<li>Git</li>
<li>í…ìŠ¤íŠ¸ ì—ë””í„° (VS Code ê¶Œì¥)</li>
<li>í„°ë¯¸ë„/ëª…ë ¹ í”„ë¡¬í”„íŠ¸</li>
</ul>
<h2 id="_7">ğŸ“š í•µì‹¬ ê°œë…</h2>
<h3 id="_8">ìê°€ ì¹˜ìœ  í…ŒìŠ¤íŠ¸ì˜ ì›ë¦¬</h3>
<p>í…ŒìŠ¤íŠ¸ê°€ ì‹¤íŒ¨í–ˆì„ ë•Œ ìë™ìœ¼ë¡œ ì›ì¸ì„ ë¶„ì„í•˜ê³  ìˆ˜ì •í•˜ì—¬ ë‹¤ì‹œ ì‹¤í–‰í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜ì„ ì´í•´í•©ë‹ˆë‹¤.</p>
<h3 id="_9">ë™ì  ìš”ì†Œ ì„ íƒ ì „ëµ</h3>
<p>ê³ ì •ëœ ì„ íƒì ëŒ€ì‹  ì—¬ëŸ¬ ì†ì„±ì„ ì¡°í•©í•˜ì—¬ ìš”ì†Œë¥¼ ì‹ë³„í•˜ëŠ” ë™ì  ì„ íƒ ì „ëµì„ ìˆ˜ë¦½í•©ë‹ˆë‹¤.</p>
<h3 id="ai">AI ê¸°ë°˜ ìš”ì†Œ ë§¤ì¹­</h3>
<p>ì»´í“¨í„° ë¹„ì „ê³¼ ìì—°ì–´ ì²˜ë¦¬ë¥¼ í™œìš©í•˜ì—¬ UI ìš”ì†Œë¥¼ ì§€ëŠ¥ì ìœ¼ë¡œ ì‹ë³„í•˜ëŠ” ë°©ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤.</p>
<h2 id="_10">ğŸ› ï¸ ì‹¤ìŠµ ë‹¨ê³„</h2>
<h3 id="_11">ìš”ì†Œ ì‹ë³„ì ë‹¤ì¤‘í™”</h3>
<p>í•˜ë‚˜ì˜ ìš”ì†Œë¥¼ ì—¬ëŸ¬ ë°©ë²•ìœ¼ë¡œ ì‹ë³„í•  ìˆ˜ ìˆëŠ” ì‹œìŠ¤í…œì„ êµ¬ì¶•í•©ë‹ˆë‹¤.</p>
<h3 id="_12">ì‹¤íŒ¨ ë¶„ì„ ì‹œìŠ¤í…œ êµ¬í˜„</h3>
<p>í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨ ì›ì¸ì„ ìë™ìœ¼ë¡œ ë¶„ì„í•˜ê³  ë¶„ë¥˜í•˜ëŠ” ì‹œìŠ¤í…œì„ ê°œë°œí•©ë‹ˆë‹¤.</p>
<h3 id="_13">ìë™ ìˆ˜ì • ë©”ì»¤ë‹ˆì¦˜ êµ¬ì¶•</h3>
<p>ë¶„ì„ëœ ì‹¤íŒ¨ ì›ì¸ì— ë”°ë¼ ìë™ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ë¥¼ ìˆ˜ì •í•˜ëŠ” ì‹œìŠ¤í…œì„ êµ¬í˜„í•©ë‹ˆë‹¤.</p>
<h3 id="_14">í•™ìŠµ ë° ê°œì„  ì‹œìŠ¤í…œ</h3>
<p>ìˆ˜ì • ê²½í—˜ì„ í•™ìŠµí•˜ì—¬ í–¥í›„ ìœ ì‚¬í•œ ë¬¸ì œë¥¼ ë” ë¹ ë¥´ê²Œ í•´ê²°í•˜ëŠ” ì‹œìŠ¤í…œì„ êµ¬ì¶•í•©ë‹ˆë‹¤.</p>
<h2 id="_15">ğŸ’» ì½”ë“œ ì˜ˆì œ</h2>
<h3 id="_16">ìê°€ ì¹˜ìœ  ìš”ì†Œ ì°¾ê¸°</h3>
<pre class="codehilite"><code class="language-python">from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time
import logging

class SelfHealingElementFinder:
    def __init__(self, driver):
        self.driver = driver
        self.wait = WebDriverWait(driver, 10)
        self.logger = logging.getLogger(__name__)

    def find_element_with_healing(self, element_info):
        &quot;&quot;&quot;ìê°€ ì¹˜ìœ  ê¸°ëŠ¥ì´ ìˆëŠ” ìš”ì†Œ ì°¾ê¸°&quot;&quot;&quot;
        strategies = [
            self.find_by_multiple_selectors,
            self.find_by_text_similarity,
            self.find_by_position,
            self.find_by_visual_similarity
        ]

        for strategy in strategies:
            try:
                element = strategy(element_info)
                if element:
                    self.logger.info(f&quot;Element found using {strategy.__name__}&quot;)
                    return element
            except Exception as e:
                self.logger.warning(f&quot;Strategy {strategy.__name__} failed: {e}&quot;)
                continue

        raise Exception(f&quot;Could not find element: {element_info}&quot;)

    def find_by_multiple_selectors(self, element_info):
        &quot;&quot;&quot;ì—¬ëŸ¬ ì„ íƒìë¡œ ìš”ì†Œ ì°¾ê¸°&quot;&quot;&quot;
        selectors = element_info.get('selectors', [])

        for selector in selectors:
            try:
                if selector['type'] == 'id':
                    return self.driver.find_element(By.ID, selector['value'])
                elif selector['type'] == 'class':
                    return self.driver.find_element(By.CLASS_NAME, selector['value'])
                elif selector['type'] == 'xpath':
                    return self.driver.find_element(By.XPATH, selector['value'])
                elif selector['type'] == 'css':
                    return self.driver.find_element(By.CSS_SELECTOR, selector['value'])
            except:
                continue

        return None

    def find_by_text_similarity(self, element_info):
        &quot;&quot;&quot;í…ìŠ¤íŠ¸ ìœ ì‚¬ë„ë¡œ ìš”ì†Œ ì°¾ê¸°&quot;&quot;&quot;
        target_text = element_info.get('text', '')
        if not target_text:
            return None

        # ëª¨ë“  í…ìŠ¤íŠ¸ ìš”ì†Œ ì°¾ê¸°
        text_elements = self.driver.find_elements(By.XPATH, &quot;//*[text()]&quot;)

        best_match = None
        best_similarity = 0

        for element in text_elements:
            element_text = element.text
            similarity = self.calculate_text_similarity(target_text, element_text)

            if similarity &gt; best_similarity and similarity &gt; 0.8:
                best_similarity = similarity
                best_match = element

        return best_match

    def calculate_text_similarity(self, text1, text2):
        &quot;&quot;&quot;í…ìŠ¤íŠ¸ ìœ ì‚¬ë„ ê³„ì‚°&quot;&quot;&quot;
        from difflib import SequenceMatcher
        return SequenceMatcher(None, text1.lower(), text2.lower()).ratio()

    def find_by_position(self, element_info):
        &quot;&quot;&quot;ìœ„ì¹˜ ê¸°ë°˜ ìš”ì†Œ ì°¾ê¸°&quot;&quot;&quot;
        position = element_info.get('position')
        if not position:
            return None

        # ìœ„ì¹˜ ê·¼ì²˜ì˜ ìš”ì†Œë“¤ ì°¾ê¸°
        x, y = position['x'], position['y']
        tolerance = 50  # í”½ì…€ í—ˆìš© ì˜¤ì°¨

        elements = self.driver.find_elements(By.XPATH, &quot;//*&quot;)

        for element in elements:
            try:
                location = element.location
                size = element.size

                if (abs(location['x'] - x) &lt; tolerance and 
                    abs(location['y'] - y) &lt; tolerance):
                    return element
            except:
                continue

        return None
</code></pre>

<h3 id="_17">í…ŒìŠ¤íŠ¸ ìë™ ìˆ˜ì • ì‹œìŠ¤í…œ</h3>
<pre class="codehilite"><code class="language-python">class TestSelfHealer:
    def __init__(self, driver):
        self.driver = driver
        self.element_finder = SelfHealingElementFinder(driver)
        self.healing_history = []

    def execute_test_with_healing(self, test_steps):
        &quot;&quot;&quot;ìê°€ ì¹˜ìœ  ê¸°ëŠ¥ì´ ìˆëŠ” í…ŒìŠ¤íŠ¸ ì‹¤í–‰&quot;&quot;&quot;
        for step in test_steps:
            try:
                self.execute_step(step)
            except Exception as e:
                self.logger.warning(f&quot;Step failed: {e}&quot;)

                # ìê°€ ì¹˜ìœ  ì‹œë„
                if self.attempt_healing(step, e):
                    self.logger.info(&quot;Healing successful, retrying step&quot;)
                    self.execute_step(step)
                else:
                    self.logger.error(&quot;Healing failed, test cannot continue&quot;)
                    raise

    def execute_step(self, step):
        &quot;&quot;&quot;í…ŒìŠ¤íŠ¸ ìŠ¤í… ì‹¤í–‰&quot;&quot;&quot;
        action = step['action']
        element_info = step['element']

        element = self.element_finder.find_element_with_healing(element_info)

        if action == 'click':
            element.click()
        elif action == 'type':
            element.clear()
            element.send_keys(step['value'])
        elif action == 'verify':
            expected = step['expected']
            actual = element.text
            assert expected in actual, f&quot;Expected '{expected}' but got '{actual}'&quot;

    def attempt_healing(self, step, error):
        &quot;&quot;&quot;í…ŒìŠ¤íŠ¸ ìŠ¤í… ìê°€ ì¹˜ìœ  ì‹œë„&quot;&quot;&quot;
        healing_strategies = [
            self.update_element_selectors,
            self.wait_for_element_load,
            self.refresh_page_and_retry,
            self.use_alternative_element
        ]

        for strategy in healing_strategies:
            try:
                if strategy(step, error):
                    self.healing_history.append({
                        'step': step,
                        'error': str(error),
                        'strategy': strategy.__name__,
                        'success': True
                    })
                    return True
            except Exception as healing_error:
                self.logger.warning(f&quot;Healing strategy {strategy.__name__} failed: {healing_error}&quot;)
                continue

        return False

    def update_element_selectors(self, step, error):
        &quot;&quot;&quot;ìš”ì†Œ ì„ íƒì ì—…ë°ì´íŠ¸&quot;&quot;&quot;
        element_info = step['element']

        # í˜„ì¬ í˜ì´ì§€ì—ì„œ ìš”ì†Œ ë‹¤ì‹œ ì°¾ê¸°
        new_element = self.element_finder.find_element_with_healing(element_info)

        if new_element:
            # ìƒˆë¡œìš´ ì„ íƒì ì •ë³´ ì—…ë°ì´íŠ¸
            element_info['selectors'] = self.extract_element_selectors(new_element)
            return True

        return False

    def wait_for_element_load(self, step, error):
        &quot;&quot;&quot;ìš”ì†Œ ë¡œë”© ëŒ€ê¸°&quot;&quot;&quot;
        time.sleep(2)  # ì¶”ê°€ ëŒ€ê¸° ì‹œê°„

        element_info = step['element']
        element = self.element_finder.find_element_with_healing(element_info)

        return element is not None

    def refresh_page_and_retry(self, step, error):
        &quot;&quot;&quot;í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ í›„ ì¬ì‹œë„&quot;&quot;&quot;
        self.driver.refresh()
        time.sleep(3)

        element_info = step['element']
        element = self.element_finder.find_element_with_healing(element_info)

        return element is not None
</code></pre>

<h2 id="_18">ğŸ” ê³ ê¸‰ ê¸°ëŠ¥</h2>
<h2 id="_19">ğŸš¨ ë¬¸ì œ í•´ê²°</h2>
<h2 id="_20">ğŸ“– ì¶”ê°€ ë¦¬ì†ŒìŠ¤</h2>
<ul>
<li><a href="https://selenium-python.readthedocs.io/">Selenium WebDriver ë¬¸ì„œ</a></li>
<li><a href="https://opencv-python-tutroals.readthedocs.io/">OpenCV Python</a></li>
<li><a href="https://scikit-learn.org/">scikit-learn</a></li>
</ul>
<h2 id="_21">ğŸš€ ë‹¤ìŒ ë‹¨ê³„</h2>
<p>ì´ ê°€ì´ë“œë¥¼ ì™„ë£Œí•œ í›„ ë‹¤ìŒ ê°€ì´ë“œë“¤ì„ í•™ìŠµí•´ë³´ì„¸ìš”:</p>
<ul>
<li><a href="2-10-shipping-dock-setup.md">ì¶œí•˜ ë¶€ë‘ êµ¬ì¶•</a></li>
<li><a href="2-11-end-to-end-project.md">ì—”ë“œ-íˆ¬-ì—”ë“œ í”„ë¡œì íŠ¸</a></li>
</ul>
<h2 id="_22">ğŸ“ ìš”ì•½</h2>
<p>ì´ ê°€ì´ë“œì—ì„œëŠ” ìê°€ ì¹˜ìœ  í…ŒìŠ¤íŠ¸ì˜ êµ¬í˜„ì— ëŒ€í•´ í•™ìŠµí–ˆìŠµë‹ˆë‹¤. ì£¼ìš” ë‚´ìš©ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:</p>
<ul>
<li>ìê°€ ì¹˜ìœ  í…ŒìŠ¤íŠ¸ ê°œë… ì´í•´ ë° ì„¤ê³„</li>
<li>ë™ì  ìš”ì†Œ ì„ íƒì ì‹œìŠ¤í…œ êµ¬í˜„</li>
<li>í…ŒìŠ¤íŠ¸ ì•ˆì •ì„± í–¥ìƒ ë©”ì»¤ë‹ˆì¦˜ êµ¬ì¶•</li>
<li>ì‹¤íŒ¨ ì‹œ ìë™ ìˆ˜ì • ì‹œìŠ¤í…œ ê°œë°œ</li>
<li>AI ê¸°ë°˜ ìš”ì†Œ ì‹ë³„ ë° ë§¤ì¹­ ì‹œìŠ¤í…œ êµ¬í˜„</li>
</ul>
<p>ë‹¤ìŒ ê°€ì´ë“œì—ì„œëŠ” ë” ê³ ê¸‰ ì£¼ì œë¥¼ ë‹¤ë£° ì˜ˆì •ì…ë‹ˆë‹¤.</p>
<hr />
<p><strong>"ìê°€ ì¹˜ìœ  í…ŒìŠ¤íŠ¸ì˜ êµ¬í˜„"</strong> - ì—ì´ì „í‹± SaaS ì¡°ì§ êµ¬ì¶•ì„ ìœ„í•œ í•µì‹¬ ê°€ì´ë“œ</p>