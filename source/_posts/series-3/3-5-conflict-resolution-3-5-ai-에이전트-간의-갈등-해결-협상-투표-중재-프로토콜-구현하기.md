---
title: 3-5: AI ì—ì´ì „íŠ¸ ê°„ì˜ ê°ˆë“± í•´ê²° - í˜‘ìƒ, íˆ¬í‘œ, ì¤‘ì¬ í”„ë¡œí† ì½œ êµ¬í˜„í•˜ê¸°
date: 2025-09-18 20:04:21
updated: 2025-09-18 20:04:21
categories: ["AI ê°€ì´ë“œ"]
tags: ["AI", "ê°€ì´ë“œ", "ìë™í™”"]
permalink: /series-3/3-5-conflict-resolution/
excerpt: 
toc: True
mathjax: True
comments: True
series:
  id: series-3
  title: ì‹œë¦¬ì¦ˆ 3: ë””ì§€í„¸ ì¸ë ¥ ê´€ë¦¬ - AI ì—ì´ì „íŠ¸ íŒ€ ìš´ì˜ì˜ í•µì‹¬
  position: 1
---
<h1 id="3-5-ai-">3-5: AI ì—ì´ì „íŠ¸ ê°„ì˜ ê°ˆë“± í•´ê²° - í˜‘ìƒ, íˆ¬í‘œ, ì¤‘ì¬ í”„ë¡œí† ì½œ êµ¬í˜„í•˜ê¸°</h1>
<h2 id="_1">ğŸ“‹ ê°œìš”</h2>
<p>AI ì—ì´ì „íŠ¸ë“¤ì´ í˜‘ì—…í•˜ëŠ” ê³¼ì •ì—ì„œ ê°ˆë“±ì´ ë°œìƒí•˜ëŠ” ê²ƒì€ ìì—°ìŠ¤ëŸ¬ìš´ í˜„ìƒì…ë‹ˆë‹¤. ì´ ê°€ì´ë“œì—ì„œëŠ” ì—ì´ì „íŠ¸ ê°„ ê°ˆë“±ì„ ì²´ê³„ì ìœ¼ë¡œ ê°ì§€, ë¶„ì„, í•´ê²°í•˜ëŠ” ë°©ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤. í˜‘ìƒ, íˆ¬í‘œ, ì¤‘ì¬ ë“± ë‹¤ì–‘í•œ ê°ˆë“± í•´ê²° í”„ë¡œí† ì½œì„ êµ¬í˜„í•˜ê³  ì‹¤ì œ ì ìš©í•˜ëŠ” ë°©ë²•ì„ ë‹¤ë£¹ë‹ˆë‹¤.</p>
<h2 id="_2">ğŸ¯ í•™ìŠµ ëª©í‘œ</h2>
<p>ì´ ê°€ì´ë“œë¥¼ ì™„ë£Œí•˜ë©´ ë‹¤ìŒì„ ë‹¬ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:</p>
<ol>
<li><strong>ê°ˆë“± ìœ í˜• ë¶„ì„</strong>: ì—ì´ì „íŠ¸ ê°„ ë°œìƒí•˜ëŠ” ë‹¤ì–‘í•œ ê°ˆë“± ìœ í˜•ì„ ë¶„ë¥˜í•˜ê³  ì´í•´</li>
<li><strong>í•´ê²° ì „ëµ ì„¤ê³„</strong>: ê°ˆë“± ìœ í˜•ë³„ ìµœì ì˜ í•´ê²° ì „ëµì„ ì„¤ê³„í•˜ê³  êµ¬í˜„</li>
<li><strong>í”„ë¡œí† ì½œ êµ¬í˜„</strong>: í˜‘ìƒ, íˆ¬í‘œ, ì¤‘ì¬ ë“± êµ¬ì²´ì ì¸ ê°ˆë“± í•´ê²° í”„ë¡œí† ì½œ êµ¬í˜„</li>
<li><strong>ì˜ˆë°© ì‹œìŠ¤í…œ êµ¬ì¶•</strong>: ê°ˆë“± ë°œìƒì„ ì‚¬ì „ì— ì˜ˆë°©í•˜ëŠ” ì‹œìŠ¤í…œ êµ¬ì¶•</li>
</ol>
<h2 id="_3">ğŸ“‹ ì‚¬ì „ ìš”êµ¬ì‚¬í•­</h2>
<ul>
<li>ì—ì´ì „íŠ¸ í˜‘ì—… ëª¨ë¸ ê¸°ë³¸ ì´í•´</li>
<li>Python ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë° ìˆ™ì§€</li>
<li>ì˜ì‚¬ê²°ì • ì´ë¡  ê¸°ë³¸ ì§€ì‹</li>
<li>íŒ€ ê´€ë¦¬ ë° ê°ˆë“± í•´ê²° ê²½í—˜</li>
</ul>
<h2 id="_4">â±ï¸ ì˜ˆìƒ ì†Œìš” ì‹œê°„</h2>
<p><strong>2.5ì‹œê°„</strong> (ë‚œì´ë„: ê³ ê¸‰)</p>
<h2 id="_5">ğŸ”§ í•„ìš”í•œ ë„êµ¬</h2>
<ul>
<li>Python 3.8+</li>
<li>CrewAI Framework</li>
<li>Redis (ìƒíƒœ ê´€ë¦¬)</li>
<li>asyncio (ë¹„ë™ê¸° ì²˜ë¦¬)</li>
<li>SQLite (ê°ˆë“± ì´ë ¥ ê´€ë¦¬)</li>
</ul>
<h2 id="_6">ğŸ“š í•µì‹¬ ê°œë…</h2>
<h3 id="1">1. ê°ˆë“±ì˜ ìœ í˜•ê³¼ íŠ¹ì„±</h3>
<h4 id="goal-conflict">ëª©í‘œ ê°ˆë“± (Goal Conflict)</h4>
<ul>
<li><strong>ì •ì˜</strong>: ì—ì´ì „íŠ¸ë“¤ì´ ì„œë¡œ ë‹¤ë¥¸ ëª©í‘œë¥¼ ì¶”êµ¬í•  ë•Œ ë°œìƒ</li>
<li><strong>ì˜ˆì‹œ</strong>: ì„±ëŠ¥ ìµœì í™” vs ë³´ì•ˆ ê°•í™”, ê°œë°œ ì†ë„ vs ì½”ë“œ í’ˆì§ˆ</li>
<li><strong>íŠ¹ì§•</strong>: ê·¼ë³¸ì ì¸ ê°€ì¹˜ ì°¨ì´ì—ì„œ ë¹„ë¡¯</li>
</ul>
<h4 id="resource-conflict">ë¦¬ì†ŒìŠ¤ ê°ˆë“± (Resource Conflict)</h4>
<ul>
<li><strong>ì •ì˜</strong>: ì œí•œëœ ë¦¬ì†ŒìŠ¤ë¥¼ ë‘ê³  ê²½ìŸí•  ë•Œ ë°œìƒ</li>
<li><strong>ì˜ˆì‹œ</strong>: CPU ì‚¬ìš©ëŸ‰, ë©”ëª¨ë¦¬ í• ë‹¹, API í˜¸ì¶œ í•œë„</li>
<li><strong>íŠ¹ì§•</strong>: ì •ëŸ‰ì ì´ê³  ì¸¡ì • ê°€ëŠ¥</li>
</ul>
<h4 id="priority-conflict">ìš°ì„ ìˆœìœ„ ê°ˆë“± (Priority Conflict)</h4>
<ul>
<li><strong>ì •ì˜</strong>: ì‘ì—…ì˜ ìš°ì„ ìˆœìœ„ì— ëŒ€í•œ ì˜ê²¬ ì°¨ì´</li>
<li><strong>ì˜ˆì‹œ</strong>: ë²„ê·¸ ìˆ˜ì • vs ìƒˆ ê¸°ëŠ¥ ê°œë°œ, ì‚¬ìš©ì ìš”ì²­ vs ê¸°ìˆ  ë¶€ì±„</li>
<li><strong>íŠ¹ì§•</strong>: ì‹œê°„ê³¼ ì¤‘ìš”ë„ì— ëŒ€í•œ ì¸ì‹ ì°¨ì´</li>
</ul>
<h4 id="communication-conflict">ì˜ì‚¬ì†Œí†µ ê°ˆë“± (Communication Conflict)</h4>
<ul>
<li><strong>ì •ì˜</strong>: ë©”ì‹œì§€ ì „ë‹¬ì´ë‚˜ ì´í•´ ê³¼ì •ì—ì„œ ë°œìƒ</li>
<li><strong>ì˜ˆì‹œ</strong>: ìš”êµ¬ì‚¬í•­ í•´ì„ ì°¨ì´, ê¸°ìˆ ì  ìš©ì–´ ì‚¬ìš© ì°¨ì´</li>
<li><strong>íŠ¹ì§•</strong>: ì¸ì§€ì  ì°¨ì´ì—ì„œ ë¹„ë¡¯</li>
</ul>
<h3 id="2">2. ê°ˆë“± í•´ê²° ì „ëµ</h3>
<h4 id="competing">ê²½ìŸ ì „ëµ (Competing)</h4>
<ul>
<li><strong>íŠ¹ì§•</strong>: í•œìª½ì˜ ì´ìµì„ ìµœëŒ€í™”</li>
<li><strong>ì ìš© ìƒí™©</strong>: ê¸´ê¸‰í•œ ìƒí™©, ëª…í™•í•œ ì •ë‹µì´ ìˆëŠ” ê²½ìš°</li>
<li><strong>ì¥ì </strong>: ë¹ ë¥¸ ì˜ì‚¬ê²°ì •</li>
<li><strong>ë‹¨ì </strong>: ê´€ê³„ ì•…í™” ê°€ëŠ¥ì„±</li>
</ul>
<h4 id="collaborating">í˜‘ë ¥ ì „ëµ (Collaborating)</h4>
<ul>
<li><strong>íŠ¹ì§•</strong>: ì–‘ìª½ ëª¨ë‘ì˜ ì´ìµì„ ìµœëŒ€í™”</li>
<li><strong>ì ìš© ìƒí™©</strong>: ì¥ê¸°ì  ê´€ê³„ê°€ ì¤‘ìš”í•œ ê²½ìš°</li>
<li><strong>ì¥ì </strong>: ì°½ì˜ì  í•´ê²°ì±… ë„ì¶œ</li>
<li><strong>ë‹¨ì </strong>: ì‹œê°„ê³¼ ë…¸ë ¥ì´ ë§ì´ ì†Œìš”</li>
</ul>
<h4 id="compromising">íƒ€í˜‘ ì „ëµ (Compromising)</h4>
<ul>
<li><strong>íŠ¹ì§•</strong>: ì–‘ìª½ ëª¨ë‘ ì¼ë¶€ ì–‘ë³´</li>
<li><strong>ì ìš© ìƒí™©</strong>: ì‹œê°„ì´ ì œí•œì ì´ê³  í•©ì˜ê°€ í•„ìš”í•œ ê²½ìš°</li>
<li><strong>ì¥ì </strong>: ë¹ ë¥¸ í•´ê²°</li>
<li><strong>ë‹¨ì </strong>: ìµœì í•´ê°€ ì•„ë‹ ìˆ˜ ìˆìŒ</li>
</ul>
<h4 id="avoiding">íšŒí”¼ ì „ëµ (Avoiding)</h4>
<ul>
<li><strong>íŠ¹ì§•</strong>: ê°ˆë“±ì„ ë¬´ì‹œí•˜ê±°ë‚˜ ë¯¸ë£¨ê¸°</li>
<li><strong>ì ìš© ìƒí™©</strong>: ê°ˆë“±ì´ ì‚¬ì†Œí•˜ê±°ë‚˜ ì‹œê°„ì´ í•„ìš”í•œ ê²½ìš°</li>
<li><strong>ì¥ì </strong>: ê´€ê³„ ë³´í˜¸</li>
<li><strong>ë‹¨ì </strong>: ê·¼ë³¸ì  í•´ê²°ì´ ì•ˆ ë¨</li>
</ul>
<h4 id="accommodating">ì–‘ë³´ ì „ëµ (Accommodating)</h4>
<ul>
<li><strong>íŠ¹ì§•</strong>: í•œìª½ì´ ë‹¤ë¥¸ ìª½ì— ì–‘ë³´</li>
<li><strong>ì ìš© ìƒí™©</strong>: ê´€ê³„ê°€ ë§¤ìš° ì¤‘ìš”í•œ ê²½ìš°</li>
<li><strong>ì¥ì </strong>: ê´€ê³„ ìœ ì§€</li>
<li><strong>ë‹¨ì </strong>: ë¶ˆê³µì •í•  ìˆ˜ ìˆìŒ</li>
</ul>
<h2 id="_7">ğŸ› ï¸ ì‹¤ìŠµ ë‹¨ê³„</h2>
<h3 id="1_1">1ë‹¨ê³„: ê°ˆë“± ê°ì§€ ì‹œìŠ¤í…œ êµ¬í˜„</h3>
<h4 id="_8">ê°ˆë“± ê°ì§€ê¸° í´ë˜ìŠ¤</h4>
<pre class="codehilite"><code class="language-python">import re
import asyncio
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from enum import Enum
from datetime import datetime

class ConflictType(Enum):
    GOAL = &quot;goal&quot;
    RESOURCE = &quot;resource&quot;
    PRIORITY = &quot;priority&quot;
    COMMUNICATION = &quot;communication&quot;

@dataclass
class Conflict:
    id: str
    type: ConflictType
    severity: float  # 0.0 ~ 1.0
    participants: List[str]
    description: str
    timestamp: datetime
    context: Dict[str, Any]

class ConflictDetector:
    def __init__(self):
        self.conflict_patterns = {
            ConflictType.GOAL: [
                r&quot;ëª©í‘œ.*ë‹¤ë¥´&quot;, r&quot;ìš°ì„ ìˆœìœ„.*ë°˜ëŒ€&quot;, r&quot;ë°©í–¥.*ë‹¤ë¦„&quot;,
                r&quot;goal.*different&quot;, r&quot;priority.*conflict&quot;
            ],
            ConflictType.RESOURCE: [
                r&quot;ë¦¬ì†ŒìŠ¤.*ë¶€ì¡±&quot;, r&quot;ë©”ëª¨ë¦¬.*ë¶€ì¡±&quot;, r&quot;CPU.*ë¶€ì¡±&quot;,
                r&quot;resource.*shortage&quot;, r&quot;memory.*full&quot;
            ],
            ConflictType.PRIORITY: [
                r&quot;ìš°ì„ ìˆœìœ„.*ë‹¤ë¦„&quot;, r&quot;ì¤‘ìš”ë„.*ë‹¤ë¦„&quot;, r&quot;ìˆœì„œ.*ë‹¤ë¦„&quot;,
                r&quot;priority.*different&quot;, r&quot;importance.*different&quot;
            ],
            ConflictType.COMMUNICATION: [
                r&quot;ì´í•´.*ì•ˆë¨&quot;, r&quot;ì†Œí†µ.*ë¬¸ì œ&quot;, r&quot;ë©”ì‹œì§€.*ë¶ˆëª…í™•&quot;,
                r&quot;misunderstanding&quot;, r&quot;communication.*issue&quot;
            ]
        }

        self.conflict_history = []

    async def detect_conflicts(self, messages: List[Dict[str, Any]]) -&gt; List[Conflict]:
        &quot;&quot;&quot;ë©”ì‹œì§€ì—ì„œ ê°ˆë“± ê°ì§€&quot;&quot;&quot;
        conflicts = []

        for message in messages:
            content = message.get('content', '').lower()
            sender = message.get('sender', 'unknown')
            timestamp = message.get('timestamp', datetime.now())

            for conflict_type, patterns in self.conflict_patterns.items():
                for pattern in patterns:
                    if re.search(pattern, content):
                        conflict = Conflict(
                            id=f&quot;conflict_{len(self.conflict_history) + 1}&quot;,
                            type=conflict_type,
                            severity=self._calculate_severity(content, pattern),
                            participants=[sender],
                            description=content,
                            timestamp=timestamp,
                            context=message
                        )
                        conflicts.append(conflict)
                        self.conflict_history.append(conflict)

        return conflicts

    def _calculate_severity(self, content: str, pattern: str) -&gt; float:
        &quot;&quot;&quot;ê°ˆë“± ì‹¬ê°ë„ ê³„ì‚°&quot;&quot;&quot;
        # ê°„ë‹¨í•œ ì‹¬ê°ë„ ê³„ì‚° (ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©)
        severity_keywords = {
            'urgent': 0.9, 'critical': 0.8, 'important': 0.6,
            'urgent': 0.9, 'critical': 0.8, 'important': 0.6,
            'ê¸´ê¸‰': 0.9, 'ì¤‘ìš”': 0.7, 'ë¬¸ì œ': 0.5
        }

        max_severity = 0.3  # ê¸°ë³¸ê°’
        for keyword, severity in severity_keywords.items():
            if keyword in content.lower():
                max_severity = max(max_severity, severity)

        return max_severity
</code></pre>

<h3 id="2_1">2ë‹¨ê³„: í˜‘ìƒ í”„ë¡œí† ì½œ êµ¬í˜„</h3>
<h4 id="_9">í˜‘ìƒ ì—ì´ì „íŠ¸</h4>
<pre class="codehilite"><code class="language-python">class NegotiationAgent:
    def __init__(self, agent_id: str, preferences: Dict[str, Any]):
        self.agent_id = agent_id
        self.preferences = preferences
        self.negotiation_history = []
        self.best_alternative = None

    async def negotiate(self, conflict: Conflict, other_agents: List[str]) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;í˜‘ìƒ í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰&quot;&quot;&quot;
        negotiation_session = {
            'conflict_id': conflict.id,
            'participants': [self.agent_id] + other_agents,
            'start_time': datetime.now(),
            'rounds': [],
            'status': 'ongoing'
        }

        # í˜‘ìƒ ë¼ìš´ë“œ ì‹¤í–‰
        for round_num in range(1, 6):  # ìµœëŒ€ 5ë¼ìš´ë“œ
            round_result = await self._execute_negotiation_round(
                conflict, other_agents, round_num
            )
            negotiation_session['rounds'].append(round_result)

            if round_result['agreement_reached']:
                negotiation_session['status'] = 'agreed'
                negotiation_session['agreement'] = round_result['agreement']
                break

        if negotiation_session['status'] == 'ongoing':
            negotiation_session['status'] = 'failed'

        negotiation_session['end_time'] = datetime.now()
        self.negotiation_history.append(negotiation_session)

        return negotiation_session

    async def _execute_negotiation_round(self, conflict: Conflict, 
                                       other_agents: List[str], 
                                       round_num: int) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;í˜‘ìƒ ë¼ìš´ë“œ ì‹¤í–‰&quot;&quot;&quot;
        # í˜„ì¬ ì…ì¥ ì œì‹œ
        my_position = await self._formulate_position(conflict, round_num)

        # ë‹¤ë¥¸ ì—ì´ì „íŠ¸ë“¤ì˜ ì…ì¥ ìˆ˜ì§‘ (ì‹œë®¬ë ˆì´ì…˜)
        other_positions = await self._collect_other_positions(other_agents, conflict)

        # í•©ì˜ ê°€ëŠ¥ì„± í‰ê°€
        agreement_possibility = self._evaluate_agreement(my_position, other_positions)

        if agreement_possibility &gt; 0.8:
            agreement = self._create_agreement(my_position, other_positions)
            return {
                'round': round_num,
                'my_position': my_position,
                'other_positions': other_positions,
                'agreement_reached': True,
                'agreement': agreement
            }
        else:
            # ë‹¤ìŒ ë¼ìš´ë“œë¥¼ ìœ„í•œ ì…ì¥ ì¡°ì •
            await self._adjust_position(conflict, other_positions)
            return {
                'round': round_num,
                'my_position': my_position,
                'other_positions': other_positions,
                'agreement_reached': False
            }

    async def _formulate_position(self, conflict: Conflict, round_num: int) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;ì…ì¥ ìˆ˜ë¦½&quot;&quot;&quot;
        base_position = {
            'agent_id': self.agent_id,
            'round': round_num,
            'demands': [],
            'concessions': [],
            'rationale': ''
        }

        if conflict.type == ConflictType.GOAL:
            base_position['demands'] = self._formulate_goal_demands(conflict)
        elif conflict.type == ConflictType.RESOURCE:
            base_position['demands'] = self._formulate_resource_demands(conflict)
        elif conflict.type == ConflictType.PRIORITY:
            base_position['demands'] = self._formulate_priority_demands(conflict)

        return base_position

    def _formulate_goal_demands(self, conflict: Conflict) -&gt; List[Dict[str, Any]]:
        &quot;&quot;&quot;ëª©í‘œ ê°ˆë“±ì— ëŒ€í•œ ìš”êµ¬ì‚¬í•­ ìˆ˜ë¦½&quot;&quot;&quot;
        return [
            {
                'type': 'goal_adjustment',
                'description': 'ëª©í‘œ ì¡°ì •ì„ í†µí•œ íƒ€í˜‘',
                'priority': 'high',
                'flexibility': 0.7
            }
        ]

    def _formulate_resource_demands(self, conflict: Conflict) -&gt; List[Dict[str, Any]]:
        &quot;&quot;&quot;ë¦¬ì†ŒìŠ¤ ê°ˆë“±ì— ëŒ€í•œ ìš”êµ¬ì‚¬í•­ ìˆ˜ë¦½&quot;&quot;&quot;
        return [
            {
                'type': 'resource_allocation',
                'description': 'ë¦¬ì†ŒìŠ¤ í• ë‹¹ ì¡°ì •',
                'priority': 'high',
                'flexibility': 0.5
            }
        ]

    def _formulate_priority_demands(self, conflict: Conflict) -&gt; List[Dict[str, Any]]:
        &quot;&quot;&quot;ìš°ì„ ìˆœìœ„ ê°ˆë“±ì— ëŒ€í•œ ìš”êµ¬ì‚¬í•­ ìˆ˜ë¦½&quot;&quot;&quot;
        return [
            {
                'type': 'priority_reordering',
                'description': 'ìš°ì„ ìˆœìœ„ ì¬ì •ë ¬',
                'priority': 'medium',
                'flexibility': 0.8
            }
        ]
</code></pre>

<h3 id="3">3ë‹¨ê³„: íˆ¬í‘œ ì‹œìŠ¤í…œ êµ¬í˜„</h3>
<h4 id="_10">íˆ¬í‘œ ê´€ë¦¬ì</h4>
<pre class="codehilite"><code class="language-python">class VotingManager:
    def __init__(self):
        self.voting_sessions = {}
        self.vote_history = []

    async def create_voting_session(self, conflict: Conflict, 
                                  options: List[Dict[str, Any]], 
                                  participants: List[str]) -&gt; str:
        &quot;&quot;&quot;íˆ¬í‘œ ì„¸ì…˜ ìƒì„±&quot;&quot;&quot;
        session_id = f&quot;vote_{len(self.voting_sessions) + 1}&quot;

        voting_session = {
            'id': session_id,
            'conflict_id': conflict.id,
            'options': options,
            'participants': participants,
            'votes': {},
            'status': 'active',
            'created_at': datetime.now(),
            'voting_rules': {
                'majority_threshold': 0.5,
                'quorum_required': True,
                'allow_abstention': True
            }
        }

        self.voting_sessions[session_id] = voting_session
        return session_id

    async def cast_vote(self, session_id: str, voter: str, 
                       option_id: str, weight: float = 1.0) -&gt; bool:
        &quot;&quot;&quot;íˆ¬í‘œ ì‹¤ì‹œ&quot;&quot;&quot;
        if session_id not in self.voting_sessions:
            return False

        session = self.voting_sessions[session_id]

        if voter not in session['participants']:
            return False

        if session['status'] != 'active':
            return False

        vote = {
            'voter': voter,
            'option_id': option_id,
            'weight': weight,
            'timestamp': datetime.now()
        }

        session['votes'][voter] = vote
        self.vote_history.append(vote)

        return True

    async def tally_votes(self, session_id: str) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;íˆ¬í‘œ ì§‘ê³„&quot;&quot;&quot;
        if session_id not in self.voting_sessions:
            return {'error': 'Session not found'}

        session = self.voting_sessions[session_id]
        votes = session['votes']

        # íˆ¬í‘œ ì§‘ê³„
        option_counts = {}
        total_weight = 0

        for vote in votes.values():
            option_id = vote['option_id']
            weight = vote['weight']

            if option_id not in option_counts:
                option_counts[option_id] = 0

            option_counts[option_id] += weight
            total_weight += weight

        # ê²°ê³¼ ê³„ì‚°
        results = []
        for option_id, count in option_counts.items():
            percentage = (count / total_weight) * 100 if total_weight &gt; 0 else 0
            results.append({
                'option_id': option_id,
                'votes': count,
                'percentage': percentage
            })

        # ìŠ¹ì ê²°ì •
        winner = max(results, key=lambda x: x['votes']) if results else None

        # ì •ì¡±ìˆ˜ í™•ì¸
        quorum_met = len(votes) &gt;= len(session['participants']) * 0.5

        result = {
            'session_id': session_id,
            'total_votes': len(votes),
            'total_weight': total_weight,
            'results': results,
            'winner': winner,
            'quorum_met': quorum_met,
            'status': 'completed' if quorum_met else 'failed'
        }

        session['status'] = 'completed'
        session['result'] = result

        return result
</code></pre>

<h3 id="4">4ë‹¨ê³„: ì¤‘ì¬ ì‹œìŠ¤í…œ êµ¬í˜„</h3>
<h4 id="_11">ì¤‘ì¬ì ì—ì´ì „íŠ¸</h4>
<pre class="codehilite"><code class="language-python">class MediatorAgent:
    def __init__(self, agent_id: str = &quot;mediator&quot;):
        self.agent_id = agent_id
        self.mediation_history = []
        self.mediation_strategies = {
            ConflictType.GOAL: self._mediate_goal_conflict,
            ConflictType.RESOURCE: self._mediate_resource_conflict,
            ConflictType.PRIORITY: self._mediate_priority_conflict,
            ConflictType.COMMUNICATION: self._mediate_communication_conflict
        }

    async def mediate(self, conflict: Conflict, 
                     participants: List[str]) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;ì¤‘ì¬ í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰&quot;&quot;&quot;
        mediation_session = {
            'conflict_id': conflict.id,
            'participants': participants,
            'mediator': self.agent_id,
            'start_time': datetime.now(),
            'phases': [],
            'status': 'ongoing'
        }

        # ì¤‘ì¬ ë‹¨ê³„ë³„ ì‹¤í–‰
        phases = ['opening', 'information_gathering', 'solution_generation', 'agreement']

        for phase in phases:
            phase_result = await self._execute_mediation_phase(
                conflict, participants, phase
            )
            mediation_session['phases'].append(phase_result)

            if phase_result['status'] == 'failed':
                mediation_session['status'] = 'failed'
                break

        if mediation_session['status'] == 'ongoing':
            mediation_session['status'] = 'successful'

        mediation_session['end_time'] = datetime.now()
        self.mediation_history.append(mediation_session)

        return mediation_session

    async def _execute_mediation_phase(self, conflict: Conflict, 
                                     participants: List[str], 
                                     phase: str) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;ì¤‘ì¬ ë‹¨ê³„ ì‹¤í–‰&quot;&quot;&quot;
        if phase == 'opening':
            return await self._opening_phase(conflict, participants)
        elif phase == 'information_gathering':
            return await self._information_gathering_phase(conflict, participants)
        elif phase == 'solution_generation':
            return await self._solution_generation_phase(conflict, participants)
        elif phase == 'agreement':
            return await self._agreement_phase(conflict, participants)

        return {'phase': phase, 'status': 'unknown'}

    async def _opening_phase(self, conflict: Conflict, 
                           participants: List[str]) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;ê°œì‹œ ë‹¨ê³„&quot;&quot;&quot;
        opening_statement = {
            'phase': 'opening',
            'mediator_statement': f&quot;ê°ˆë“± {conflict.id}ì— ëŒ€í•œ ì¤‘ì¬ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.&quot;,
            'ground_rules': [
                &quot;ëª¨ë“  ì°¸ê°€ìëŠ” ì„œë¡œë¥¼ ì¡´ì¤‘í•´ì•¼ í•©ë‹ˆë‹¤&quot;,
                &quot;í•œ ë²ˆì— í•œ ëª…ì”© ë°œì–¸í•´ì•¼ í•©ë‹ˆë‹¤&quot;,
                &quot;ê°œì¸ì  ê³µê²©ì€ ê¸ˆì§€ë©ë‹ˆë‹¤&quot;,
                &quot;í•´ê²°ì±…ì— ì§‘ì¤‘í•´ì•¼ í•©ë‹ˆë‹¤&quot;
            ],
            'status': 'completed'
        }

        return opening_statement

    async def _information_gathering_phase(self, conflict: Conflict, 
                                         participants: List[str]) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;ì •ë³´ ìˆ˜ì§‘ ë‹¨ê³„&quot;&quot;&quot;
        # ê° ì°¸ê°€ìì˜ ì…ì¥ ìˆ˜ì§‘
        positions = {}
        for participant in participants:
            position = await self._gather_participant_position(conflict, participant)
            positions[participant] = position

        # ê°ˆë“±ì˜ í•µì‹¬ ì´ìŠˆ íŒŒì•…
        core_issues = self._identify_core_issues(positions)

        return {
            'phase': 'information_gathering',
            'positions': positions,
            'core_issues': core_issues,
            'status': 'completed'
        }

    async def _solution_generation_phase(self, conflict: Conflict, 
                                       participants: List[str]) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;í•´ê²°ì±… ìƒì„± ë‹¨ê³„&quot;&quot;&quot;
        # ê°ˆë“± ìœ í˜•ë³„ ì¤‘ì¬ ì „ëµ ì ìš©
        strategy = self.mediation_strategies.get(conflict.type)
        if strategy:
            solutions = await strategy(conflict, participants)
        else:
            solutions = await self._generic_solution_generation(conflict, participants)

        return {
            'phase': 'solution_generation',
            'solutions': solutions,
            'status': 'completed'
        }

    async def _mediate_goal_conflict(self, conflict: Conflict, 
                                   participants: List[str]) -&gt; List[Dict[str, Any]]:
        &quot;&quot;&quot;ëª©í‘œ ê°ˆë“± ì¤‘ì¬&quot;&quot;&quot;
        return [
            {
                'type': 'goal_integration',
                'description': 'ìƒì¶©í•˜ëŠ” ëª©í‘œë“¤ì„ í†µí•©í•˜ì—¬ ìƒˆë¡œìš´ ëª©í‘œ ìƒì„±',
                'feasibility': 0.8,
                'acceptance_likelihood': 0.7
            },
            {
                'type': 'goal_prioritization',
                'description': 'ëª©í‘œì— ìš°ì„ ìˆœìœ„ë¥¼ ë¶€ì—¬í•˜ì—¬ ë‹¨ê³„ì  ë‹¬ì„±',
                'feasibility': 0.9,
                'acceptance_likelihood': 0.8
            },
            {
                'type': 'goal_compromise',
                'description': 'ê° ëª©í‘œì˜ ì¼ë¶€ë¥¼ ì–‘ë³´í•˜ì—¬ íƒ€í˜‘ì•ˆ ë„ì¶œ',
                'feasibility': 0.7,
                'acceptance_likelihood': 0.6
            }
        ]

    async def _mediate_resource_conflict(self, conflict: Conflict, 
                                      participants: List[str]) -&gt; List[Dict[str, Any]]:
        &quot;&quot;&quot;ë¦¬ì†ŒìŠ¤ ê°ˆë“± ì¤‘ì¬&quot;&quot;&quot;
        return [
            {
                'type': 'resource_sharing',
                'description': 'ë¦¬ì†ŒìŠ¤ë¥¼ ì‹œê°„ëŒ€ë³„ë¡œ ê³µìœ í•˜ì—¬ ì‚¬ìš©',
                'feasibility': 0.8,
                'acceptance_likelihood': 0.7
            },
            {
                'type': 'resource_optimization',
                'description': 'ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ì„ ìµœì í™”í•˜ì—¬ íš¨ìœ¨ì„± ì¦ëŒ€',
                'feasibility': 0.9,
                'acceptance_likelihood': 0.8
            },
            {
                'type': 'resource_expansion',
                'description': 'ì¶”ê°€ ë¦¬ì†ŒìŠ¤ë¥¼ í™•ë³´í•˜ì—¬ ê°ˆë“± í•´ê²°',
                'feasibility': 0.6,
                'acceptance_likelihood': 0.9
            }
        ]
</code></pre>

<h2 id="_12">ğŸ’» ì½”ë“œ ì˜ˆì œ</h2>
<h3 id="_13">ì™„ì „í•œ ê°ˆë“± í•´ê²° ì‹œìŠ¤í…œ</h3>
<pre class="codehilite"><code class="language-python">class ConflictResolutionSystem:
    def __init__(self):
        self.detector = ConflictDetector()
        self.negotiation_agents = {}
        self.voting_manager = VotingManager()
        self.mediator = MediatorAgent()
        self.resolution_history = []

    async def resolve_conflict(self, conflict: Conflict, 
                             participants: List[str]) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;ê°ˆë“± í•´ê²° í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰&quot;&quot;&quot;
        resolution_plan = self._create_resolution_plan(conflict, participants)

        if resolution_plan['strategy'] == 'negotiation':
            result = await self._execute_negotiation(conflict, participants)
        elif resolution_plan['strategy'] == 'voting':
            result = await self._execute_voting(conflict, participants)
        elif resolution_plan['strategy'] == 'mediation':
            result = await self._execute_mediation(conflict, participants)
        else:
            result = await self._execute_hybrid_resolution(conflict, participants)

        # ê²°ê³¼ ê¸°ë¡
        resolution_record = {
            'conflict_id': conflict.id,
            'strategy': resolution_plan['strategy'],
            'participants': participants,
            'result': result,
            'timestamp': datetime.now()
        }

        self.resolution_history.append(resolution_record)
        return result

    def _create_resolution_plan(self, conflict: Conflict, 
                              participants: List[str]) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;í•´ê²° ì „ëµ ê³„íš ìˆ˜ë¦½&quot;&quot;&quot;
        # ê°ˆë“± ìœ í˜•ê³¼ ì‹¬ê°ë„ì— ë”°ë¥¸ ì „ëµ ì„ íƒ
        if conflict.severity &gt; 0.8:
            if conflict.type == ConflictType.GOAL:
                return {'strategy': 'mediation', 'reason': 'high_severity_goal_conflict'}
            else:
                return {'strategy': 'voting', 'reason': 'high_severity_quick_resolution'}
        elif len(participants) &gt; 5:
            return {'strategy': 'voting', 'reason': 'large_group_decision'}
        elif conflict.type == ConflictType.COMMUNICATION:
            return {'strategy': 'mediation', 'reason': 'communication_issue_requires_mediation'}
        else:
            return {'strategy': 'negotiation', 'reason': 'standard_negotiation_process'}

    async def _execute_negotiation(self, conflict: Conflict, 
                                 participants: List[str]) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;í˜‘ìƒ ì‹¤í–‰&quot;&quot;&quot;
        # í˜‘ìƒ ì—ì´ì „íŠ¸ë“¤ ì´ˆê¸°í™”
        negotiation_agents = []
        for participant in participants:
            agent = NegotiationAgent(participant, {})
            negotiation_agents.append(agent)

        # í˜‘ìƒ ì‹¤í–‰
        negotiation_results = []
        for agent in negotiation_agents:
            other_agents = [p for p in participants if p != agent.agent_id]
            result = await agent.negotiate(conflict, other_agents)
            negotiation_results.append(result)

        # í˜‘ìƒ ê²°ê³¼ í†µí•©
        successful_negotiations = [r for r in negotiation_results if r['status'] == 'agreed']

        if successful_negotiations:
            return {
                'status': 'resolved',
                'method': 'negotiation',
                'agreements': successful_negotiations,
                'success_rate': len(successful_negotiations) / len(negotiation_results)
            }
        else:
            return {
                'status': 'failed',
                'method': 'negotiation',
                'reason': 'no_agreement_reached'
            }

    async def _execute_voting(self, conflict: Conflict, 
                            participants: List[str]) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;íˆ¬í‘œ ì‹¤í–‰&quot;&quot;&quot;
        # íˆ¬í‘œ ì˜µì…˜ ìƒì„±
        options = self._generate_voting_options(conflict)

        # íˆ¬í‘œ ì„¸ì…˜ ìƒì„±
        session_id = await self.voting_manager.create_voting_session(
            conflict, options, participants
        )

        # íˆ¬í‘œ ì‹¤ì‹œ (ì‹œë®¬ë ˆì´ì…˜)
        for participant in participants:
            # ê°„ë‹¨í•œ íˆ¬í‘œ ë¡œì§ (ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ ë¡œì§)
            option_id = options[0]['id']  # ì²« ë²ˆì§¸ ì˜µì…˜ ì„ íƒ
            await self.voting_manager.cast_vote(session_id, participant, option_id)

        # íˆ¬í‘œ ì§‘ê³„
        result = await self.voting_manager.tally_votes(session_id)

        return {
            'status': 'resolved' if result['status'] == 'completed' else 'failed',
            'method': 'voting',
            'result': result
        }

    async def _execute_mediation(self, conflict: Conflict, 
                               participants: List[str]) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;ì¤‘ì¬ ì‹¤í–‰&quot;&quot;&quot;
        mediation_result = await self.mediator.mediate(conflict, participants)

        return {
            'status': 'resolved' if mediation_result['status'] == 'successful' else 'failed',
            'method': 'mediation',
            'result': mediation_result
        }
</code></pre>

<h2 id="_14">ğŸ” ê³ ê¸‰ ê¸°ëŠ¥</h2>
<h3 id="1_2">1. ê°ˆë“± ì˜ˆë°© ì‹œìŠ¤í…œ</h3>
<pre class="codehilite"><code class="language-python">class ConflictPreventionSystem:
    def __init__(self):
        self.prevention_rules = []
        self.early_warning_signals = []

    def add_prevention_rule(self, rule: Dict[str, Any]):
        &quot;&quot;&quot;ì˜ˆë°© ê·œì¹™ ì¶”ê°€&quot;&quot;&quot;
        self.prevention_rules.append(rule)

    async def monitor_for_conflicts(self, messages: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:
        &quot;&quot;&quot;ê°ˆë“± ì¡°ê¸° ê²½ê³  ëª¨ë‹ˆí„°ë§&quot;&quot;&quot;
        warnings = []

        for rule in self.prevention_rules:
            if self._check_rule_violation(messages, rule):
                warning = {
                    'rule_id': rule['id'],
                    'severity': rule['severity'],
                    'message': rule['warning_message'],
                    'timestamp': datetime.now()
                }
                warnings.append(warning)

        return warnings
</code></pre>

<h3 id="2_2">2. ê°ˆë“± í•´ê²° ì„±ê³¼ ë¶„ì„</h3>
<pre class="codehilite"><code class="language-python">class ConflictResolutionAnalytics:
    def __init__(self):
        self.metrics = {
            'resolution_rate': 0,
            'average_resolution_time': 0,
            'method_effectiveness': {},
            'conflict_frequency': 0
        }

    def analyze_resolution_performance(self, resolution_history: List[Dict]) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;í•´ê²° ì„±ê³¼ ë¶„ì„&quot;&quot;&quot;
        total_resolutions = len(resolution_history)
        successful_resolutions = len([r for r in resolution_history if r['result']['status'] == 'resolved'])

        resolution_rate = successful_resolutions / total_resolutions if total_resolutions &gt; 0 else 0

        # ë°©ë²•ë³„ íš¨ê³¼ì„± ë¶„ì„
        method_stats = {}
        for record in resolution_history:
            method = record['strategy']
            if method not in method_stats:
                method_stats[method] = {'total': 0, 'successful': 0}

            method_stats[method]['total'] += 1
            if record['result']['status'] == 'resolved':
                method_stats[method]['successful'] += 1

        for method, stats in method_stats.items():
            method_stats[method]['success_rate'] = stats['successful'] / stats['total']

        return {
            'overall_resolution_rate': resolution_rate,
            'method_effectiveness': method_stats,
            'total_conflicts': total_resolutions,
            'successful_resolutions': successful_resolutions
        }
</code></pre>

<h2 id="_15">ğŸš¨ ë¬¸ì œ í•´ê²°</h2>
<h3 id="1_3">1. í˜‘ìƒ êµì°© ìƒíƒœ</h3>
<p><strong>ë¬¸ì œ</strong>: í˜‘ìƒì´ ì§„í–‰ë˜ì§€ ì•Šê³  êµì°© ìƒíƒœì— ë¹ ì§</p>
<p><strong>í•´ê²°ì±…</strong>:
- ì‹œê°„ ì œí•œ ì„¤ì •
- ì¤‘ì¬ì ê°œì…
- ëŒ€ì•ˆ í•´ê²°ì±… ì œì‹œ</p>
<h3 id="2_3">2. íˆ¬í‘œ ë¬´íš¨í™”</h3>
<p><strong>ë¬¸ì œ</strong>: ì •ì¡±ìˆ˜ ë¯¸ë‹¬ë¡œ íˆ¬í‘œê°€ ë¬´íš¨í™”ë¨</p>
<p><strong>í•´ê²°ì±…</strong>:
- ì •ì¡±ìˆ˜ ê¸°ì¤€ ì¡°ì •
- ì¶”ê°€ íˆ¬í‘œ ê¸°ê°„ ì„¤ì •
- ëŒ€ì•ˆ ì˜ì‚¬ê²°ì • ë°©ë²• ì‚¬ìš©</p>
<h3 id="3_1">3. ì¤‘ì¬ ì‹¤íŒ¨</h3>
<p><strong>ë¬¸ì œ</strong>: ì¤‘ì¬ìê°€ ê°ˆë“±ì„ í•´ê²°í•˜ì§€ ëª»í•¨</p>
<p><strong>í•´ê²°ì±…</strong>:
- ì¤‘ì¬ì êµì²´
- í•˜ì´ë¸Œë¦¬ë“œ ì ‘ê·¼ë²• ì‚¬ìš©
- ìƒê¸‰ ì¤‘ì¬ì ê°œì…</p>
<h2 id="_16">ğŸ“– ì¶”ê°€ ë¦¬ì†ŒìŠ¤</h2>
<ul>
<li><a href="https://conflict-resolution-theory.com/">ê°ˆë“± í•´ê²° ì´ë¡ </a></li>
<li><a href="https://negotiation-strategies.dev/">í˜‘ìƒ ì „ëµ ê°€ì´ë“œ</a></li>
<li><a href="https://mediation-techniques.org/">ì¤‘ì¬ ê¸°ë²• ëª¨ìŒ</a></li>
<li><a href="https://team-conflict-management.dev/">íŒ€ ê°ˆë“± ê´€ë¦¬</a></li>
</ul>
<h2 id="_17">ğŸš€ ë‹¤ìŒ ë‹¨ê³„</h2>
<p>ì´ ê°€ì´ë“œë¥¼ ì™„ë£Œí•œ í›„ ë‹¤ìŒ ê°€ì´ë“œë“¤ì„ í•™ìŠµí•´ë³´ì„¸ìš”:</p>
<ul>
<li><a href="3-6-coder-to-conductor.md">3-6: ì½”ë”ì—ì„œ ì§€íœ˜ìë¡œ</a> - ì—ì´ì „í‹± ì‹œëŒ€ì˜ ì¸ê°„ ê°œë°œìì˜ ì—­í•  ì¬ì •ì˜</li>
<li><a href="3-7-future-core-skills.md">3-7: ë¯¸ë˜ì˜ í•µì‹¬ ì—­ëŸ‰</a> - í”„ë¡¬í”„íŠ¸ ìœ ì°½ì„±, ì œì•½ ì¡°ê±´ ì„¤ê³„, ì—ì´ì „í‹± ì‚¬ê³  í›ˆë ¨í•˜ê¸°</li>
<li><a href="3-8-strategic-validation.md">3-8: ì „ëµì  ê²€ì¦ì˜ ê¸°ìˆ </a> - AI ê²°ê³¼ë¬¼ì„ ë¹„ì¦ˆë‹ˆìŠ¤ ëª©í‘œì™€ ì •ë ¬í•˜ëŠ” ë°©ë²•</li>
</ul>
<h2 id="_18">ğŸ“ ìš”ì•½</h2>
<p>ì´ ê°€ì´ë“œì—ì„œëŠ” AI ì—ì´ì „íŠ¸ ê°„ ê°ˆë“± í•´ê²°ì˜ í•µì‹¬ ê°œë…ì„ í•™ìŠµí–ˆìŠµë‹ˆë‹¤:</p>
<ul>
<li><strong>ê°ˆë“± ìœ í˜•</strong>: ëª©í‘œ, ë¦¬ì†ŒìŠ¤, ìš°ì„ ìˆœìœ„, ì˜ì‚¬ì†Œí†µ ê°ˆë“±</li>
<li><strong>í•´ê²° ì „ëµ</strong>: í˜‘ìƒ, íˆ¬í‘œ, ì¤‘ì¬ ë“± ë‹¤ì–‘í•œ ì ‘ê·¼ë²•</li>
<li><strong>í”„ë¡œí† ì½œ êµ¬í˜„</strong>: êµ¬ì²´ì ì´ê³  ì‹¤í–‰ ê°€ëŠ¥í•œ í•´ê²° ì‹œìŠ¤í…œ</li>
<li><strong>ì˜ˆë°© ì‹œìŠ¤í…œ</strong>: ê°ˆë“± ë°œìƒì„ ì‚¬ì „ì— ë°©ì§€í•˜ëŠ” ì²´ê³„</li>
</ul>
<p>ë‹¤ìŒ ê°€ì´ë“œì—ì„œëŠ” ì¸ê°„ ê°œë°œìì˜ ì—­í•  ë³€í™”ì— ëŒ€í•´ ë‹¤ë£° ì˜ˆì •ì…ë‹ˆë‹¤.</p>
<hr />
<p><strong>"ê°ˆë“±ì„ ê¸°íšŒë¡œ, í˜‘ë ¥ì„ ì„±ê³µìœ¼ë¡œ"</strong> - ì²´ê³„ì ì¸ ê°ˆë“± í•´ê²° ì‹œìŠ¤í…œìœ¼ë¡œ AI íŒ€ì˜ í˜‘ì—…ì„ ìµœì í™”í•˜ì„¸ìš”!</p>